###　堆排序
排序方法非常多，这里的堆排序很好理解，就是指利用堆这种数据结构所设计的一种排序算法。具体排序思路如下：假定是升序排序，利用堆的性质，先由待排序数组构造最大堆，满足堆性质后，因为根节点是最大值，所以每次弹出根节点，即为有序数组，但这样描述不是十分严谨，比较严谨的描述如下：
1. 构造最大堆。
2. 交换数组中第一个元素（堆中根节点元素）和数组中最后一个元素，数组长度减一。
3. 执行“下移”操作，将第一个元素“下移”到满足堆性质。
4. 不断执行步骤2，直到最后仅剩一个元素。

时间复杂度分析：构造堆`O(n)`，依次弹出根节点，共`n`次，每次的时间复杂度`O(log(n))`，所以有｀O(n+nlog(n))=O(nlog(n))｀。空间复杂度｀O(1)｀。

### 具体实现
算法描述如下：
```
// a为带排序数组， count元素个数
procedure heapsort(a, count)
    heapify(a, count);   // 构造堆

    end = count - 1;
    while end > 0
        swap(a[end], a[0]);
        end = end - 1;
        siftDown(a, 0, end);

// 将数组堆化， a为待排序数组， count元素个数
procedure heapify(a, count) 
    // 这里元素在数组中的位置从0开始， iParent(count-1)指的是最后一个元素的父节点
    start = iParent(count-1)
    while start >= 0 do
        siftDown(a, start, count-1)
        start = start - 1   //下一个非叶子节点

// 堆根节点为start的堆进行堆化（保证父节点大于等于子节点）
procedure siftDown(a, start, end)
    root = start
    while iLeftChild(root) <= end
        // 其实这块主要是选左右子节点中最大的一个，与之交换，代码实现有很多方法，这里只是其中一种
        child = iLeftChild(root)
        swap = root 

        if a[swap] < a[child]
            swap = child
        if child+1 <= end and a[swap] < a[child+1]  // 如果右子节点存在且大于左子节点大于父节点，就设置swap为右子节点
            swap = child + 1
        if swap = root
            return  // 已满足堆性质，返回
        else
            swap(a[root], a[swap])
            root = swap
```


这里的实现主要是由待排序数组构造堆的实现，可参考

