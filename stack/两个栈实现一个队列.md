 #### <font color=blue>问题：如何用两个栈实现一个对列的功能？</font>
思路：从栈A入队列，从栈B出队列。（队列的2个最重要的操作，入队列，出队列。）
- 入队列：从栈A入队列。
- 出队列：分两种情况
    - 如果栈B不为空，直接弹出。
    - 如果栈B为空，将栈A中的数据全部弹入栈B中，再从栈B弹出数据

[代码实现](./stack2queue.cpp)如下：
```c++
//2个栈实现一个队列
#include<stack>
#include<cassert>
#include<iostream>
using namespace std;

template<class T>
class Queue
{
public:
	Queue(){}
	virtual ~Queue(){}

	void push(const T& e) {
		m_stackA.push(e);
	}

	void pop() {
		if(m_stackB.empty()) {
			while(!m_stackA.empty()) {
				m_stackB.push(m_stackA.top());
				m_stackA.pop();
			}
		}
		m_stackB.pop();
	}

	size_t size() const {
		return m_stackA.size() + m_stackB.size();
	}

	bool empty() {
		return m_stackA.empty() && m_stackB.empty();
	}

	T top() {
		if(m_stackB.empty()) {
			while(!m_stackA.empty()) {
				m_stackB.push(m_stackA.top());
				m_stackA.pop();
			}
		}
		return m_stackB.top();
	}

protected:
	stack<T> m_stackA;	//栈A
	stack<T> m_stackB;	//栈B
};

int main() {
	Queue<int> m_queue;
	m_queue.push(1);
	m_queue.push(2);
    assert(m_queue.top() == 1);
    m_queue.pop();
    assert(2 == m_queue.top());

	return 0;
}
```

#### <font color=blue>引申思考：如何用两个队列实现一个栈的功能？</font>
思路：  
举个例子：有`D-->C-->B-->A`数据依次入栈，输出顺序应该是`A-->B-->C-->D`。    
先将`D-->C-->B-->A`入队列1，将`C-->B-->A`弹出到队列2，只留一个，弹出`D`；   
再将队列2中所有数据入队列1，继续上面的步骤......        
大体就这个思路。