## 红黑树
红黑树是一种自平衡二叉查找树，可以在`O(log(n))`时间内完成查找、插入和删除。相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。红黑树较AVL树等二叉树的不同在于其有个标识位（红色或者黑色），这个标识位的作用在于减少因不平衡造成的旋转操作，虽然此时树不是完全平衡二叉树，但依然有`O(log(n)`的时间效率。

### 红黑树的性质
红黑树要满足如下性质：
1. Each node is either red or black. 节点是红色或者黑色
2. The root is black. 根是黑色
3. All leaves (NIL) are black. 所有叶子（NIL节点）都是黑色
4. If a node is red, then both its children are black. 每个红色节点必须有两个黑色节点（从每个叶子节点到根的所有路径上不能有两个连续的红色节点）
5. Every path from a given node to any of its descendant NIL nodes contains the same number of black nodes. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点

![](../images/red-black_tree_example.svg.png)  

这些约束确保了红黑树的关键特性：**从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**。结果是这棵树大致上是平衡的，这与扩展AVL树（增大平衡因子以减少旋转，提高效率）的思想基本一致。红黑树相较于AVL树，对平衡性的要求有了一定的降低，以AVL树的角度看红黑树，有些时候即使平衡因子超过1也不会触发旋转操作，但不意味着红黑树的平衡性能不好（在保证整体平衡性的情况下牺牲一点点平衡性以减少旋转换取时间效率），正是这个特性使得红黑树的效率优于AVL树。

红黑树这个关键特性是为什么呢？解析如下：由性质4可推导出一个路径不能有两个毗连的红色节点，而性质5又要求从任一节点到每个叶子节点的所有简单路径都包含相同数目的黑色节点。我们知道，最短的可能路径是节点都是黑色，最长的可能路径是有交替的红色和黑色节点，因为性质5，黑色节点数目相同，所以可以得出没有路径能多于任何其他路径的两倍长。


### 红黑树的实现
现在我们开始实现红黑树，摆在我们面前的问题有：新插入一个节点，它应该是红色的呢还是黑色的呢？在插入或删除操作中，如果破坏了红黑树的性质，该怎么操作呢？这里最重要的插入和删除操作。

#### 插入
我们首先以二叉查找树的方法增加节点并标记它为红色。如果设为黑色，由于性质5，会导致根到叶子的路径上有一条路上多了一个额外的黑节点，这个是很难调整的，但设为红色节点后，可能会出现两个连续红色节点的冲突，那么可通过颜色调换和树旋转来调整。这里树旋转与AVL树类似。

我们继续分析插入操作的情况：
- 性质1和性质3总是保持着；
- 性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁；
- 性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁；

在下面的示意图中，将要插入的节点标为N，N的父节点标为P，N的祖父节点标为G，N的叔父节点标为U。如同AVL插入的过程，插入分为如下几种情形：
>叔父节点：父节点的兄弟节点。

**情形1：** 新节点N位于树的根上，没有父节点。这种情形下，我们把它重绘为黑色以满足性质2。
```c++
void insert_case1(Node* n) {
    if (nullptr == n->parent)
        n->color = ecolor::black;
    else
        insert_case2(n);
}
```

**情形2：** 新节点N的父节点P是黑色。在这种情形下，因为新节点N是红色，性质4与性质5都没有发生改变，此时树仍然有效。
```c++
void insert_case2(Node* n) {
    if (n->parent->color == ecolor::black)
        return;
    else
        insert_case3(n);
}
```

**情形3：** 如果父节点P和叔父节点U都是红色。则我们可将P和U重绘为黑色并重绘G为红色。但这样会带来如下问题：重绘为红色的祖父节点G有可能是根节点，这违反了性质2，也有可能祖父节点G的父节点是红色的，这违反了性质4，为了解决这个问题，我们在祖父节点G上递归地进行情形1的整个过程。       
![](../images/Red-black_tree_insert_case_3.png)       
```c++
void insert_case3(Node* n) {
    if (n->uncle() != nullptr && n->uncle()->color == ecolor::red) {
        n->parent->color = ecolor::black;
        n->uncle()->color = ecolor::black;
        n->grandparent()->color = ecolor::red;
        insert_case1(n->grandparent());
    } else
        insert_case4(n);
}
```

**情形4：** 如果父节点P是红色而叔父节点U是黑色或者是缺少（NIL），并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。（镜像对称的情况也是如此）。在这种情形下，我们进行一次坐旋转调换新节点和其父节点的角色；接着，我们按情形5处理以前的父节点P以解决仍然失效的性质4。         
![image](../images/Red-black_tree_insert_case_4.png)          
```c++
void insert_case4(Node* n) {
    if (n == n->parent->right && n->parent == n->grandparent()->left) {
        rotate_left(n);     //fixme
        n = n->left;
    } else if (n == n->parent->left && n->parent == n->grandparent()->right) {
        rotate_right(n);    // fixme
        n = n->right;
    }
    insert_case5(n);
}
```

**情形5：** 如果父节点P是红色而叔父节点U是黑色或者缺少（NIL），新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。（镜像对称的情况也是如此）。在这种情形下，我们进行一次针对祖父节点G的右旋转；在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G一定是黑色（否则违反性质4），右旋后，我们切换以前的父节点P和祖父节点G的颜色，这样既满足了性质4又保证了性质5。
![image](../images/Red-black_tree_insert_case_5.png)      
```c++
void insert_case5(Node* n) {
    n->parent->color = ecolor::black;
    n->grandparent()->color = ecolor::red;
    if (n == n->parent->left && n->parent == n->grandparent()->left)
        rotate_right(n->parent);    //fixme
    else
        rotate_left(n->parent);     //fixme
}
```

#### 删除
删除操作要比插入复杂一些。如果要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题。这是因为删除一个节点可以用复制删除，寻找一个左子树的最大值或右子树的最小值节点复制到要被删除的节点，然后问题转化为删除那个最大值或最小值节点。











---
> Reference:        
[Red-black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)          
[红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)    