## 红黑树
红黑树是一种自平衡二叉查找树，可以在`O(log(n))`时间内完成查找、插入和删除。相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。红黑树较AVL树等二叉树的不同在于其有个标识位（红色或者黑色），这个标识位的作用在于减少因不平衡造成的旋转操作，虽然此时树不是完全平衡二叉树，但依然有`O(log(n)`的时间效率。

### 红黑树的性质
红黑树要满足如下性质：
1. Each node is either red or black. 节点是红色或者黑色
2. The root is black. 根是黑色
3. All leaves (NIL) are black. 所有叶子（NIL节点）都是黑色
4. If a node is red, then both its children are black. 每个红色节点必须有两个黑色节点（从每个叶子节点到根的所有路径上不能有两个连续的红色节点）
5. Every path from a given node to any of its descendant NIL nodes contains the same number of black nodes. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点

![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/500px-Red-black_tree_example.svg.png)  

这些约束确保了红黑树的关键特性：**从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**。结果是这棵树大致上是平衡的，这与扩展AVL树（增大平衡因子以减少旋转，提高效率）的思想基本一致。正是这个特性使得红黑树的效率优于AVL树。

红黑树这个关键特性是为什么呢？解析如下：由性质4可推导出一个路径不能有两个毗连的红色节点，而性质5又要求从任一节点到每个叶子节点的所有简单路径都包含相同数目的黑色节点。我们知道，最短的可能路径是节点都是黑色，最长的可能路径是有交替的红色和黑色节点，因为性质5，黑色节点数目相同，所以可以得出没有路径能多于任何其他路径的两倍长。


### 红黑树的实现
现在我们开始实现红黑树，摆在我们面前的问题有：新插入一个节点，它应该是红色的呢还是黑色的呢？在插入或删除操作中，如果破坏了红黑树的性质，该怎么操作呢？这里最重要的插入和删除操作。

#### 插入
我们首先以二叉查找树的方法增加节点并标记它为红色。如果设为黑色，由于性质5，会导致根到叶子的路径上有一条路上多了一个额外的黑节点，这个是很难调整的，但设为红色节点后，可能会出现两个连续红色节点的冲突，那么可通过颜色调换和树旋转来调整。

我们继续分析插入操作的情况：
- 性质1和性质3总是保持着；
- 性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁；
- 性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁；

在下面的示意图中，将要插入的节点标为N，N的父节点标为P，N的祖父节点标为G，N的叔父节点标为U。如同AVL插入的过程，插入分为如下几种情形：
>叔父节点：父节点的兄弟节点。

**情形1：** 新节点N位于树的根上，没有父节点。这种情形下，我们把它重绘为黑色以满足性质2。
```c++
// template<class T>
void insert_case1(Node<T>* n) {
    if (nullptr == n->parent)
        n->color = ecolor::black;
    else
        insert_case2(n);
}
```









---
> Reference:        
[Red-black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)      